/* autogenerated by Processing revision 1286 on 2022-10-02 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Comparator;
import java.util.PriorityQueue;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class camera extends PApplet {

// Created for CSCI 5611 by Liam Tyler

// WASD keys move the camera relative to its current orientation
// Arrow keys rotate the camera's orientation
// Holding shift boosts the move speed

boolean centerMode = false;
PVector forwardDir; 
PVector upDir;
PVector rightDir;   

class Camera
{
  Camera()
  {
    position      = new PVector( 600, -600, 600 ); // initial position
    theta         = 0; // rotation around Y axis. Starts with forward direction as ( 0, 0, -1 )
    phi           = 0; // rotation around X axis. Starts with up direction as ( 0, 1, 0 )
    moveSpeed     = 60;
    turnSpeed     = 1.7f; // radians/sec
    boostSpeed    = 5;  // extra speed boost for when you press shift
    
    // dont need to change these
    shiftPressed = false;
    negativeMovement = new PVector( 0, 0, 0 );
    positiveMovement = new PVector( 0, 0, 0 );
    verticalMovement = new PVector( 0, 0, 0 );
    negativeTurn     = new PVector( 0, 0 ); // .x for theta, .y for phi
    positiveTurn     = new PVector( 0, 0 );
    fovy             = PI / 4;
    aspectRatio      = width / (float) height;
    nearPlane        = 0.1f;
    farPlane         = 10000;
  }

   public void Update(float dt)
  {
    if (cameraFollowAgent) {
      if (agentBackYDown) agentBackY += 5;
      if (agentBackYUp) agentBackY -= 5;
      camera( 
        agentPos.x+backDir.x*2,agentPos.y+agentBackY, agentPos.z+backDir.y*2,
        agentPos.x, agentPos.y, agentPos.z,
        0, 1, 0 
      );
      return;
    }

    if (firstPerson) {
      camera(
        agentPos.x + forwardDir2.x*10, agentPos.y-agentColRad*0.85f, agentPos.z + forwardDir2.y*10,
        agentPos.x + forwardDir2.x*100, agentPos.y, agentPos.z + forwardDir2.y*100,
        0,1,0
      );
      return;
    }

    theta += turnSpeed * ( negativeTurn.x + positiveTurn.x)*dt;
    
    // cap the rotation about the X axis to be less than 90 degrees to avoid gimble lock
    float maxAngleInRadians = 85 * PI / 180;
    phi = min( maxAngleInRadians, max( -maxAngleInRadians, phi + turnSpeed * ( negativeTurn.y + positiveTurn.y ) * dt ) );
    
    // re-orienting the angles to match the wikipedia formulas: https://en.wikipedia.org/wiki/Spherical_coordinate_system
    // except that their theta and phi are named opposite
    float t = theta + PI / 2;
    float p = phi + PI / 2;
    forwardDir = new PVector( sin( p ) * cos( t ),   cos( p ),   -sin( p ) * sin ( t ) );
    upDir      = new PVector( sin( phi ) * cos( t ), cos( phi ), -sin( t ) * sin( phi ) );
    rightDir   = new PVector( cos( theta ), 0, -sin( theta ) );
    if (negativeMovement.mag() > 0) negativeMovement.normalize();
    if (positiveMovement.mag() > 0) positiveMovement.normalize();
    if (verticalMovement.mag() > 0) verticalMovement.normalize();

    if (shiftPressed){
      positiveMovement.mult(boostSpeed);
      negativeMovement.mult(boostSpeed);
      verticalMovement.mult(boostSpeed);
    }

    PVector velocity   = new PVector( 
      negativeMovement.x + positiveMovement.x + verticalMovement.x, 
      negativeMovement.y + positiveMovement.y + verticalMovement.y, 
      negativeMovement.z + positiveMovement.z 
    );

    position.add( PVector.mult( forwardDir, moveSpeed * velocity.z * dt ) );
    position.add( PVector.mult( upDir,      moveSpeed * velocity.y * dt ) );
    position.add( PVector.mult( rightDir,   moveSpeed * velocity.x * dt ) );
    
    aspectRatio = width / (float) height;
    
    perspective( fovy, aspectRatio, nearPlane, farPlane );
    camera( 
      position.x, position.y, position.z,
      position.x + forwardDir.x, position.y + forwardDir.y, position.z + forwardDir.z,
      upDir.x, upDir.y, upDir.z 
    );
  }
  
  // only need to change if you want difrent keys for the controls
   public void HandleKeyPressed()
  {
    if ( key == 'w' || key == 'W' ) {
      if (!cameraFollowAgent) positiveMovement.z = 1;
      else agentBackYUp = true;
    }
    if ( key == 's' || key == 'S' ) {
      if (!cameraFollowAgent) negativeMovement.z = -1;
      else agentBackYDown = true;
    }
    if ( key == 'a' || key == 'A' ) negativeMovement.x = -1;
    if ( key == 'd' || key == 'D' ) positiveMovement.x = 1;
    if ( key == ' ' ) negativeMovement.y = -1;
    if ( keyCode == CONTROL ) positiveMovement.y = 1;
    if ( key == 'R' ){
      Camera defaults = new Camera();
      position = defaults.position;
      theta = defaults.theta;
      phi = defaults.phi;
    }
    if ( key == 'v' && !firstPerson) cameraFollowAgent = true;
    
    if ( keyCode == LEFT )  negativeTurn.x = 1;
    if ( keyCode == RIGHT ) positiveTurn.x = -0.5f;
    if ( keyCode == UP )    positiveTurn.y = 0.5f;
    if ( keyCode == DOWN )  negativeTurn.y = -1;
    if ( keyCode == BACKSPACE ) goalSpeed = 200;
    if ( keyCode == SHIFT ) shiftPressed = true; 
  }
  
  // only need to change if you want difrent keys for the controls
   public void HandleKeyReleased()
  {
    if ( key == 'w' || key == 'W' ) {
      if (!cameraFollowAgent) positiveMovement.z = 0;
      else agentBackYUp = false;
    }
    if ( key == ' ' ) negativeMovement.y = 0;
    if ( key == 'd' || key == 'D' ) positiveMovement.x = 0;
    if ( key == 'a' || key == 'A' ) negativeMovement.x = 0;
    if ( key == 's' || key == 'S' ) {
      if (!cameraFollowAgent) negativeMovement.z = 0;
      else agentBackYDown = false;
    }
    if ( keyCode == CONTROL ) positiveMovement.y = 0;
    if ( key == 'v' ) cameraFollowAgent = false;
    if ( key == 'f' && !cameraFollowAgent) firstPerson = !firstPerson;
    
    if ( keyCode == LEFT  ) negativeTurn.x = 0;
    if ( keyCode == RIGHT ) positiveTurn.x = 0;
    if ( keyCode == UP    ) positiveTurn.y = 0;
    if ( keyCode == DOWN  ) negativeTurn.y = 0;
    if ( keyCode == BACKSPACE ) goalSpeed = 100;
    
    if ( keyCode == SHIFT ){
      shiftPressed = false;
      positiveMovement.mult(1.0f/boostSpeed);
      negativeMovement.mult(1.0f/boostSpeed);
    }
  }
  
  // only necessary to change if you want different start position, orientation, or speeds
  PVector position;
  float theta;
  float phi;
  float moveSpeed;
  float turnSpeed;
  float boostSpeed;
  
  // probably don't need / want to change any of the below variables
  float fovy;
  float aspectRatio;
  float nearPlane;
  float farPlane;  
  PVector negativeMovement;
  PVector positiveMovement;
  PVector verticalMovement;
  PVector negativeTurn;
  PVector positiveTurn;
  boolean shiftPressed;
};




// ----------- Example using Camera class -------------------- //
// Camera camera;

// void setup()
// {
//   size(600, 600, P3D);
//   camera = new Camera();
// }

// void keyPressed()
// {
//   camera.HandleKeyPressed();
// }

// void keyReleased()
// {
//   camera.HandleKeyReleased();
// }

// void draw() {
//   background(255);
//   noLights();

//   camera.Update(1.0/frameRate);
  
//   // draw six cubes surrounding the origin (front, back, left, right, top, bottom)
//   fill( 0, 0, 255 );
//   pushMatrix();
//   translate( 0, 0, -50 );
//   box( 20 );
//   popMatrix();
  
//   pushMatrix();
//   translate( 0, 0, 50 );
//   box( 20 );
//   popMatrix();
  
//   fill( 255, 0, 0 );
//   pushMatrix();
//   translate( -50, 0, 0 );
//   box( 20 );
//   popMatrix();
  
//   pushMatrix();
//   translate( 50, 0, 0 );
//   box( 20 );
//   popMatrix();
  
//   fill( 0, 255, 0 );
//   pushMatrix();
//   translate( 0, 50, 0 );
//   box( 20 );
//   popMatrix();
  
//   pushMatrix();
//   translate( 0, -50, 0 );
//   box( 20 );
//   popMatrix();
// }
//You will only be turning in this file
//Your solution will be graded based on it's runtime (smaller is better), 
//the optimality of the path you return (shorter is better), and the
//number of collisions along the path (it should be 0 in all cases).

//You must provide a function with the following prototype:
// ArrayList<Integer> planPath(Vec2 startPos, Vec2 goalPos, Vec2[] centers, float[] radii, int numObstacles, Vec2[] nodePos, int numNodes);
// Where: 
//    -startPos and goalPos are 2D start and goal positions
//    -centers and radii are arrays specifying the center and radius of obstacles
//    -numObstacles specifies the number of obstacles
//    -nodePos is an array specifying the 2D position of roadmap nodes
//    -numNodes specifies the number of nodes in the PRM
// The function should return an ArrayList of node IDs (indexes into the nodePos array).
// This should provide a collision-free chain of direct paths from the start position
// to the position of each node, and finally to the goal position.
// If there is no collision-free path between the start and goal, return an ArrayList with
// the 0'th element of "-1".

// Your code can safely make the following assumptions:
//   - The function connectNeighbors() will always be called before planPath()
//   - The variable maxNumNodes has been defined as a large static int, and it will
//     always be bigger than the numNodes variable passed into planPath()
//   - None of the positions in the nodePos array will ever be inside an obstacle
//   - The start and the goal position will never be inside an obstacle

// There are many useful functions in CollisionLibrary.pde and Vec2.pde
// which you can draw on in your implementation. Please add any additional 
// functionality you need to this file (PRM.pde) for compatabilty reasons.

// Here we provide a simple PRM implementation to get you started.
// Be warned, this version has several important limitations.
// For example, it uses BFS which will not provide the shortest path.
// Also, it (wrongly) assumes the nodes closest to the start and goal
// are the best nodes to start/end on your path on. Be sure to fix 
// these and other issues as you work on this assignment. This file is
// intended to illustrate the basic set-up for the assignmtent, don't assume 
// this example funcationality is correct and end up copying it's mistakes!).




//Here, we represent our graph structure as a neighbor list
//You can use any graph representation you like
ArrayList<Integer>[] neighbors = new ArrayList[maxNumNodes+2];  //A list of neighbors can can be reached from a given node
//We also want some help arrays to keep track of some information about nodes we've visited
Boolean[] visited = new Boolean[maxNumNodes+2]; //A list which store if a given node has been visited
int[] parent = new int[maxNumNodes+2]; //A list which stores the best previous node on the optimal path to reach this node
Vec2[] obstCenters;
float[] obstRadii;
int numObst;
Vec2[] newNodePos = new Vec2[numNodes+2];
PriorityQueue<Float>[] closedd = new PriorityQueue[numNodes+2];
PriorityQueue<Node>[] open = new PriorityQueue[numNodes+2];

PriorityQueue<Node> closed = new PriorityQueue<Node>(numNodes);
PriorityQueue<Node> fringe = new PriorityQueue<Node>(numNodes+2);

ArrayList<Integer> path = new ArrayList();

//Set which nodes are connected to which neighbors (graph edges) based on PRM rules
 public void connectNeighbors(Vec2[] centers, float[] radii, int numObstacles, Vec2[] nodePos, int numNodes){
  obstCenters = centers;
  obstRadii = radii;
  numObst = numObstacles;

  for (int i = 0; i < numNodes; i++) {
    newNodePos[i+1] = nodePos[i];
  }

  for (int i = 1; i < numNodes+1; i++){
    neighbors[i] = new ArrayList<Integer>();  //Clear neighbors list
    for (int j = 1; j < numNodes+1; j++){
      if (i == j) continue; //don't connect to myself 
      Vec2 dir = newNodePos[j].minus(newNodePos[i]).normalized();
      float distBetween = newNodePos[i].distanceTo(newNodePos[j]);
      hitInfo circleListCheck = rayCircleListIntersect(centers, radii, numObstacles, newNodePos[i], dir, distBetween);
      if (!circleListCheck.hit){
        neighbors[i].add(j);
      } 
    }
  }
}

//This is probably a bad idea and you shouldn't use it...
 public void connectStartAndGoal(int numNodes, Vec2[] centers, float[] radii, int numObstacles) {
  neighbors[0] = new ArrayList<Integer>();
  neighbors[numNodes-1] = new ArrayList<Integer>();

  for (int i = 0; i < numNodes; i++) {
    if (i != 0) {
      Vec2 dir = newNodePos[i].minus(newNodePos[0]).normalized();
      float distBetween = newNodePos[0].distanceTo(newNodePos[i]);
      hitInfo circleListCheck = rayCircleListIntersect(centers, radii, numObstacles, newNodePos[0], dir, distBetween);
      if (!circleListCheck.hit){
        neighbors[0].add(i);
      }
    }
    if (i != numNodes-1) {
      Vec2 dir = newNodePos[i].minus(newNodePos[numNodes-1]).normalized();
      float distBetween = newNodePos[numNodes-1].distanceTo(newNodePos[i]);
      hitInfo circleListCheck = rayCircleListIntersect(centers, radii, numObstacles, newNodePos[numNodes-1], dir, distBetween);
      neighbors[i].remove(Integer.valueOf(numNodes-1));
      if (!circleListCheck.hit){
        neighbors[i].add(numNodes-1);
      }
    }
  }
}

 public ArrayList<Integer> planPath(Vec2 startPos, Vec2 goalPos, Vec2[] centers, float[] radii, int numObstacles, Vec2[] nodePos, int numNodes){
  path.clear();

  newNodePos[0] = startPos;
  newNodePos[numNodes+1] = goalPos;
  
  connectStartAndGoal(numNodes+2, centers, radii, numObstacles);
  
  path = runAStar(newNodePos, numNodes+2, 0, numNodes+1);

  return path;
}

class Node implements Comparable<Node> {
  public Float g;
  public Float h;
  public Float cost;
  public int id;

  public Node(int id, float g, float h) {
    this.id = id;
    this.g = g;
    this.h = h;
    
    this.cost = this.g+this.h;
  }

  public boolean equals(Object o) {
    if (o instanceof Node) {
      Node toCompare = (Node) o;
      return (this.id==toCompare.id);
    }
    return false;
  }

  @Override
  public int compareTo(Node n2) {
    return this.cost.compareTo(n2.cost);
  }
}

 public float heuristic1(int currNode, int goalNode, Vec2[] nodePos) {
  return nodePos[currNode].distanceTo(nodePos[goalNode]);
}

 public ArrayList<Integer> runAStar(Vec2[] nodePos, int numNodes, int startID, int goalID) {
  closed.clear();
  fringe.clear();
  ArrayList<Integer> path = new ArrayList();

  for (int i = 0; i < numNodes; i++) { //Clear visit tags and parent pointers
    parent[i] = -1; //No parent yet
  }

  //println("\nBeginning Search");
  
  fringe.offer(new Node(startID, 0, heuristic1(startID, goalID, nodePos)));
  while (fringe.size() > 0){
    Node currentNode = fringe.poll();
    if (currentNode.id == goalID){
      break;
    }
    
    for (int i = 0; i < neighbors[currentNode.id].size(); i++){
      int neighborNodeID = neighbors[currentNode.id].get(i);
      Node neighbor = new Node(
        neighborNodeID, 
        currentNode.g + nodePos[currentNode.id].distanceTo(nodePos[neighborNodeID]),
        heuristic1(neighborNodeID, goalID, nodePos)
      );

      if (fringe.contains(neighbor)) {
        boolean cont = false;
        for (Node n : fringe) {
          if (n.g <= neighbor.g && n.equals(neighbor)) {
            cont = true;
            break;
          }
        }
        if (cont) {
          continue;
        }
      } else if (closed.contains(neighbor)) {
        boolean cont = false;
        for (Node n : closed) {
          if (n.g <= neighbor.g && n.equals(neighbor)) {
            cont = true;
            break;
          }
          else if (n.equals(neighbor)) {
            closed.remove(n);
            fringe.offer(n);
          }
        }
        if (cont) {
          continue;
        }
      } else {
        fringe.offer(neighbor);
      }
      parent[neighbor.id] = currentNode.id;
    } 
    closed.offer(currentNode);
  }

  if (fringe.size() == 0){
    //println("No Path");
    path.add(0,-1);
    return path;
  }
    
  //print("\nReverse path: ");
  int prevNode = parent[goalID];
  path.add(0,goalID);
  // print(goalID, " ");
  while (prevNode >= 0){
    //print(prevNode," ");
    path.add(0,prevNode);
    prevNode = parent[prevNode];
  }
  //print("\n");

  return path;
}


class hitInfo{
  public boolean hit = false;
  public float t = 9999999;
}

 public hitInfo rayCircleIntersect(Vec2 center, float r, Vec2 l_start, Vec2 l_dir, float max_t){
  hitInfo hit = new hitInfo();
  
  //Step 2: Compute W - a displacement vector pointing from the start of the line segment to the center of the circle
  Vec2 toCircle = center.minus(l_start);
  
  //Step 3: Solve quadratic equation for intersection point (in terms of l_dir and toCircle)
  float a = 1;  //Length of l_dir (we normalized it)
  float b = -2*dot(l_dir,toCircle); //-2*dot(l_dir,toCircle)
  float c = toCircle.lengthSqr() - (r+strokeWidth)*(r+strokeWidth); //different of squared distances
  
  float d = b*b - 4*a*c; //discriminant 
  
  if (d >=0 ){ 
    //If d is positive we know the line is colliding, but we need to check if the collision line within the line segment
    //  ... this means t will be between 0 and the length of the line segment
    float t1 = (-b - sqrt(d))/(2*a); //Optimization: we only need the first collision
    float t2 = (-b + sqrt(d))/(2*a); //Optimization: we only need the first collision
    //println(hit.t,t1,t2);
    if (t1 > 0 && t1 < max_t){
      hit.hit = true;
      hit.t = t1;
    }
    else if (t1 < 0 && t2 > 0){
      hit.hit = true;
      hit.t = -1;
    }
    
  }
    
  return hit;
}

 public hitInfo rayCircleListIntersect(Vec2[] centers, float[] radii,  int numObstacles, Vec2 l_start, Vec2 l_dir, float max_t){
  hitInfo hit = new hitInfo();
  hit.t = max_t;
  for (int i = 0; i < numObstacles; i++){
    if (validCircles[i]) {
      Vec2 center = centers[i];
      float r = radii[i];
      
      hitInfo circleHit = rayCircleIntersect(center, r, l_start, l_dir, hit.t);
      if (circleHit.t > 0 && circleHit.t < hit.t){
        hit.hit = true;
        hit.t = circleHit.t;
      }
      else if (circleHit.hit && circleHit.t < 0){
        hit.hit = true;
        hit.t = -1;
      }
    }
  }
  return hit;
}

// main draw loop
 public void draw() {
    // updates things
    float dt = 1.0f/frameRate;
    camera.Update(dt);
    checkPressed();
    if (!paused) {
        update(dt);
        updateKiwiFrame();
        updateKiwiParticles(dt);
    }

    if (is3d) {
        background(0);
        drawSkyBox();
        colorMode(HSB, 360, 100, 100);
        lightFalloff(1, 0, 0);
        lightSpecular(0, 0, 0);
        ambientLight(35,35,35);
        directionalLight(0,0,100, 1, 0, 0);
        colorMode(RGB, 256, 256, 256);

        // draws obstacles, agent and floor if you want
        drawObstacles(dt);
        drawPointLight();
        drawKiwi();
        drawShips();
        drawParticles();
        drawStartAndGoal();
        // drawing the boundaries of axes for debugging
        // drawBounds();

        // drawFloor();
        // //Draw graph
        // stroke(50,50,50);
        // strokeWeight(1);
        // for (int i = 0; i < numNodes+2; i++){
        //     for (int j : neighbors[i]){
        //     line(newNodePos[i].x, 0, newNodePos[i].y,newNodePos[j].x,0,newNodePos[j].y);
        //     }
        // }

        
        // if (curPath.size() >0 && curPath.get(0) == -1) return; //No path found
        
        // //Draw Planned Path
        // stroke(20,255,40);
        // strokeWeight(5);
        // if (curPath.size() == 0){
        //     line(startPos.x,0,startPos.y,goalPos.x,0,goalPos.y);
        //     return;
        // }
        // for (int i = 0; i < curPath.size()-1; i++){
        //     int curNode = curPath.get(i);
        //     int nextNode = curPath.get(i+1);
        //     line(newNodePos[curNode].x,0,newNodePos[curNode].y,newNodePos[nextNode].x,0,newNodePos[nextNode].y);
        // }
    } else {
        strokeWeight(1);
        background(200); //Grey background
        stroke(0,0,0);
        fill(255,255,255);
        
        
        //Draw the circle obstacles
        for (int i = 0; i < numObstacles; i++){
            if (validCircles[i]) {
                Vec2 c = circlePosArr[i];
                float r = circleRadArr[i];
                circle(c.x,c.y,r*2);
            }
        }
        //Draw the first circle a little special b/c the user controls it
        fill(240);
        strokeWeight(2);
        circle(circlePosArr[0].x,circlePosArr[0].y,circleRadArr[0]*2);
        strokeWeight(1);
        
        //Draw PRM Nodes
        fill(0);
        for (int i = 0; i < numNodes; i++){
            circle(nodePos[i].x,nodePos[i].y,5);
        }
        
        //Draw graph
        stroke(100,100,100);
        strokeWeight(1);
        for (int i = 0; i < numNodes+2; i++){
            for (int j : neighbors[i]){
            line(newNodePos[i].x,newNodePos[i].y,newNodePos[j].x,newNodePos[j].y);
            }
        }
        
        //Draw Start and Goal
        fill(20,60,250);
        //circle(nodePos[startNode].x,nodePos[startNode].y,20);
        circle(agentPos.x,agentPos.z,20);
        fill(250,30,50);
        //circle(nodePos[goalNode].x,nodePos[goalNode].y,20);
        circle(goalPos.x,goalPos.y,20);
        
        if (curPath.size() >0 && curPath.get(0) == -1) return; //No path found
        
        //Draw Planned Path
        stroke(20,255,40);
        strokeWeight(5);
        if (curPath.size() == 0){
            line(startPos.x,startPos.y,goalPos.x,goalPos.y);
            return;
        }
        line(startPos.x,startPos.y,newNodePos[curPath.get(0)].x,newNodePos[curPath.get(0)].y);
        for (int i = 0; i < curPath.size()-1; i++){
            int curNode = curPath.get(i);
            int nextNode = curPath.get(i+1);
            line(newNodePos[curNode].x,newNodePos[curNode].y,newNodePos[nextNode].x,newNodePos[nextNode].y);
        }
        line(goalPos.x,goalPos.y,newNodePos[curPath.get(curPath.size()-1)].x,newNodePos[curPath.get(curPath.size()-1)].y);
        noStroke();
    }
    
}

 public void drawShips() {
    if (!paused) {
        ship1Rot += ship1RotRate;
        ship2Rot += ship2RotRate;
    }
    
    pushMatrix();
        translate(goalPos.x, -250, goalPos.y);
        rotateZ(oneeighty);
        rotateY(ship1Rot);
        scale(2);
        shape(ship);
    popMatrix();
    pushMatrix();
        translate(absStartPos.x, -250, absStartPos.y);
        rotateZ(oneeighty);
        rotateY(ship2Rot);
        scale(2);
        shape(ship);
    popMatrix();
}

 public void drawStartAndGoal() {
    // this code was gotten from how to draw a cylinder
    // https://vormplus.be/full-articles/drawing-a-cylinder-with-processing 
    float sides = 10;
    float h = 400;
    float r = 20;
    float angle = 360 / sides;
    float halfHeight = h / 2;
    // draw top shape
    pushMatrix();
        translate(absStartPos.x, -100, absStartPos.y);
        rotateX(radians(90));
        fill(255,0,0, 50);
        beginShape();
            for (int i = 0; i < sides; i++) {
                float x = cos( radians( i * angle ) ) * r;
                float y = sin( radians( i * angle ) ) * r;
                vertex( x, y, -halfHeight );    
            }
        endShape(CLOSE);
        // draw bottom shape
        beginShape();
            for (int i = 0; i < sides; i++) {
                float x = cos( radians( i * angle ) ) * r;
                float y = sin( radians( i * angle ) ) * r;
                vertex( x, y, halfHeight );    
            }
        endShape(CLOSE);
        beginShape(TRIANGLE_STRIP);
            for (int i = 0; i < sides + 1; i++) {
                float x = cos( radians( i * angle ) ) * r;
                float y = sin( radians( i * angle ) ) * r;
                vertex( x, y, halfHeight);
                vertex( x, y, -halfHeight);    
            }
        endShape(CLOSE);
        noFill();
    popMatrix();

    fill(0,255,0, 50);
    pushMatrix();
        translate(goalPos.x, -100, goalPos.y);
        rotateX(radians(90));
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos( radians( i * angle ) ) * r;
            float y = sin( radians( i * angle ) ) * r;
            vertex( x, y, -halfHeight );    
        }
        endShape(CLOSE);
        // draw bottom shape
        beginShape();
        for (int i = 0; i < sides; i++) {
            float x = cos( radians( i * angle ) ) * r;
            float y = sin( radians( i * angle ) ) * r;
            vertex( x, y, halfHeight );    
        }
        endShape(CLOSE);
        beginShape(TRIANGLE_STRIP);
        for (int i = 0; i < sides + 1; i++) {
            float x = cos( radians( i * angle ) ) * r;
            float y = sin( radians( i * angle ) ) * r;
            vertex( x, y, halfHeight);
            vertex( x, y, -halfHeight);    
        }
        endShape(CLOSE);
    popMatrix();
    noFill();
}

 public void drawParticles() {
    sphereDetail(2);
    for (int i = numParticles-1; i >= 0; i--) {
        Vec3 pos = particlePos.get(i);
        Vec3 col = particleCol.get(i);
        float life = particleLife.get(i);
        float alpha = 255;
        if (life > maxLife*0.3f) {
            alpha = 150-life*300;
        }
        fill(col.x, col.y, col.z, alpha);
        pushMatrix();
            translate(pos.x, pos.y, pos.z);
            sphere(3);
        popMatrix();
    }
}

// draws coordinate system of scene for debugging
 public void drawBounds() {
    // x axis --> red
    stroke(255,0,0);
    line(0,0,0,3000,0,0);
    line(0,0,0,-3000,0,0);
    

    // y axis --> green
    stroke(0,255,0);
    line(0,0,0,0,3000,0);
    line(0,0,0,0,-3000,0);

    // z axis --> blue
    stroke(0,0,255);
    line(0,0,0,0,0,3000);
    line(0,0,0,0,0,-3000);
    noStroke();
}

// // drawing borders of the scene
// void drawFloor() {
//     noStroke();
//     fill(1,0,0);
//     float x = sceneX/100;
//     float z = sceneZ/100;
//     for (int i = 0; i < 100; i++) {
//         for (int j = 0; j < 100; j++) {
//             pushMatrix();
//                 translate((-sceneX*0.5) + i*x, 5, (-sceneZ*0.5) + j*z);
//                 box(x, 10, z);
//             popMatrix();
//         }
//     }
//     strokeWeight(strokeWidth);
// }

// draw obstacles :)
 public void drawObstacles(float dt) {
    noFill();
    for (int i = 0; i < numObstacles; i++) {
        float rot = circleRot.get(i);
        Float[] tilt = circleTilt.get(i);
        Vec3 currPos = circlePos.get(i);
        float currRad = circleDrawRad.get(i);
        // fill(currCol.x, currCol.y, currCol.z);
        pushMatrix();
            translate(currPos.x, currPos.y, currPos.z);
            rotateX(tilt[0]);
            rotateZ(tilt[1]);
            rotateY(rot);
            shape(circleShape.get(i));
        popMatrix();
    }   
}

 public void drawSkyBox() {
    // pushMatrix();
    // textureMode(NORMAL);
    // float size = 5000;
    // for(int i = 0; i < 6; i++)
    // {
    //   beginShape();
    //   texture(skybox[i]);
    //   vertex(size - (size * 2), size,              (size - 1) - ((size - 1) * 2), 0, 0);
    //   vertex(size,              size,              (size - 1) - ((size - 1) * 2), 1, 0);
    //   vertex(size,              size - (size * 2), (size - 1) - ((size - 1) * 2), 1, 1);
    //   vertex(size - (size * 2), size - (size * 2), (size - 1) - ((size - 1) * 2), 0, 1);
    //   endShape();
    //   if(i < 4)  rotateY(HALF_PI);
    //   if(i == 3) rotateX(HALF_PI);
    //   if(i >= 4) rotateX(PI);
    //   if(i == 5) rotateY(PI);
    // }
    // popMatrix();
    pushMatrix();
        shape(back);
    popMatrix();
}

 public void drawPointLight() {
    colorMode(HSB, 360, 100, 100);
    lightFalloff(0.5f, 0, 0);
    pointLight(
        0,0,100,
        agentPos.x, agentPos.y-50, agentPos.z
    );
    colorMode(RGB, 256, 256, 256);
}

// void drawMouseRay() {
//   strokeWeight(3);
//   stroke(0);
//   line(
//     mouseOrig.x, 
//     mouseOrig.y, 
//     mouseOrig.z,
//     mouseOrig.x + mouseRay.x*10000, 
//     mouseOrig.y + mouseRay.y*10000, 
//     mouseOrig.z + mouseRay.z*10000
//   );
//   strokeWeight(strokeWidth);
// }

 public void drawKiwi() {
    pushMatrix();  
        translate(agentPos.x, agentPos.y, agentPos.z);
        rotateY(agentDir);
        scale(kiwiScale);
        shape(shapes[currFrame]);
    popMatrix();

    // draws the collision
    // pushMatrix();
    //     noFill();
    //     strokeWeight(strokeWidth);
    //     stroke(255);
    //     translate(agentPos.x, agentPos.y, agentPos.z);
    //     sphere(agentColRad);
    // popMatrix();
}
 public void checkPressed() {
    if (shipMoveNeg.length() > 0) shipMoveNeg.normalize();
    if (shipMovePos.length() > 0) shipMovePos.normalize();
    shipMove.x = shipMoveNeg.x + shipMovePos.x;
    shipMove.y = shipMoveNeg.y + shipMovePos.y;
    // goalPos.x += shipMove.x*5;
    // goalPos.y += shipMove.y*5;

    cameraForward.x = forwardDir.x; cameraForward.y = forwardDir.z;
    cameraForward.normalize();

    cameraBackward.x = cameraForward.x*-1;
    cameraBackward.y = cameraForward.y*-1;

    cameraRight.x = rightDir.x; cameraRight.y = rightDir.z;
    cameraRight.normalize();

    cameraLeft.x = cameraRight.x*-1;
    cameraLeft.y = cameraRight.y*-1;

    cameraLeft.mul(shipMoveNeg.y);
    cameraRight.mul(shipMovePos.y);
    cameraForward.mul(shipMovePos.x);
    cameraBackward.mul(shipMoveNeg.x);

    Vec2 direction = cameraForward.plus(cameraBackward.plus(cameraRight.plus(cameraLeft)));

    direction.mul(5);
    goalPos.add(direction);

    if (direction.x != 0 || direction.y != 0) {
        if (!atGoal) {
            startPos.x = agentPos.x; startPos.y = agentPos.z;

            if (!startOrGoalInCircleList(circlePosArr, circleRadArr, numObstacles, goalPos, epsilon)) {
                curPath = planPath(startPos, goalPos, circlePosArr, circleRadArr, numObstacles, nodePos, numNodes);
                noGoal = false;
                indexCounter = 1;
                nextNode = curPath.get(1);
                goalNode = curPath.get(curPath.size()-1);
                nextPos = newNodePos[nextNode];
                agentVel = nextPos.minus(startPos).normalized().times(goalSpeed);
                return;
            }
            noGoal = true;
            return;
        }
        agentPos.x = goalPos.x;
        agentPos.z = goalPos.y;
    }
}

 public void mouseWheel(MouseEvent event) {
    
}

 public void mouseReleased() {
  // mouseCast = true;
  // mouseRay = cameraRay(mouseX, mouseY);
  // mouseOrig = new Vec3(camera.position.x, camera.position.y, camera.position.z);
}

 public void keyPressed()
{
    camera.HandleKeyPressed();
    if ( key == 'i' || key == 'I' ) {
        shipMovePos.x = 1;
    }
    if ( key == 'j' || key == 'J' ) {
        shipMoveNeg.y = 1;
    }
    if ( key == 'l' || key == 'L' ) {
        shipMovePos.y = 1;
    }
    if ( key == 'k' || key == 'K' ) {
        shipMoveNeg.x = 1;
    }
}

 public void keyReleased()
{
    camera.HandleKeyReleased();
    if (key == 'r') reset();
    if (key == 'p') paused = !paused;
    if (key == 'c') is3d = !is3d;
    if ( key == 'i' || key == 'I' ) {
        shipMovePos.x = 0;
    }
    if ( key == 'j' || key == 'J' ) {
        shipMoveNeg.y = 0;
    }
    if ( key == 'l' || key == 'L' ) {
        shipMovePos.y = 0;
    }
    if ( key == 'k' || key == 'K' ) {
        shipMoveNeg.x = 0;
    }
}

// Vec3 cameraRay(float x, float y) {
//   float imageAspectRatio = camera.aspectRatio;  //assuming width > height 
//   float px = (2 * ((x + 0.5) / displayWidth) - 1) * tan(camera.fovy / 2 * PI / 180) * imageAspectRatio; 
//   float py = (1 - 2 * ((y + 0.5) / displayHeight) * tan(camera.fovy / 2 * PI / 180)); 
//   Vec3 rayOrigin = new Vec3(camera.position.x, camera.position.y, camera.position.z); 
//   Vec3 rayDirection = new Vec3(px, py, -1);  //note that this just equal to Vec3f(Px, Py, -1); 
//   rayDirection = rayDirection.normalized();  //it's a direction so don't forget to normalize
//   return rayDirection;
// }
//Change the below parameters to change the scenario/roadmap size
static int numNodes  = 400;
  
//A list of circle obstacles
static int maxNumObstacles = 1000;
static int initObstacles = 600;
int numObstacles = initObstacles;
boolean[] validCircles = new boolean[maxNumObstacles];
Vec2 circlePosArr[] = new Vec2[maxNumObstacles]; //Circle positions
float circleRadArr[] = new float[maxNumObstacles];  //Circle radii

static int maxNumNodes = 1000;
Vec2[] nodePos = new Vec2[maxNumNodes];

ArrayList<Integer> curPath = new ArrayList<Integer>();

//Generate non-colliding PRM nodes
 public void generateRandomNodes(int numNodes, Vec2[] circleCenters, float[] circleRadii){
  for (int i = 0; i < numNodes; i++){
    Vec2 randPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f),random(-sceneZ*0.5f, sceneZ*0.5f));
    boolean insideAnyCircle = pointInCircleList(circleCenters,circleRadii,numObstacles,randPos,2);
    //boolean insideBox = pointInBox(boxTopLeft, boxW, boxH, randPos);
    while (insideAnyCircle){
      randPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f),random(-sceneZ*0.5f, sceneZ*0.5f));
      insideAnyCircle = pointInCircleList(circleCenters,circleRadii,numObstacles,randPos,2);
      //insideBox = pointInBox(boxTopLeft, boxW, boxH, randPos);
    }
    nodePos[i] = randPos;
  }
}

int numCollisions;
float pathLength;
boolean reachedGoal;
 public void pathQuality(){
  Vec2 dir;
  hitInfo hit;
  float segmentLength;
  numCollisions = 9999; pathLength = 9999;
  if (curPath.size() == 1 && curPath.get(0) == -1) return; //No path found  
  
  pathLength = 0; numCollisions = 0;
  
  if (curPath.size() == 2){ //Path found with no nodes (direct start-to-goal path)
    segmentLength = startPos.distanceTo(goalPos);
    pathLength += segmentLength;
    dir = goalPos.minus(startPos).normalized();
    hit = rayCircleListIntersect(circlePosArr, circleRadArr, numObstacles, startPos, dir, segmentLength);
    if (hit.hit) numCollisions += 1;
    return;
  }
  
  segmentLength = startPos.distanceTo(newNodePos[curPath.get(1)]);
  pathLength += segmentLength;
  dir = newNodePos[curPath.get(1)].minus(startPos).normalized();
  hit = rayCircleListIntersect(circlePosArr, circleRadArr, numObstacles, startPos, dir, segmentLength);
  if (hit.hit) numCollisions += 1;
  
  
  for (int i = 1; i < curPath.size()-2; i++){
    int curNode = curPath.get(i);
    int nextNode = curPath.get(i+1);
    segmentLength = newNodePos[curNode].distanceTo(newNodePos[nextNode]);
    pathLength += segmentLength;
    
    dir = newNodePos[nextNode].minus(newNodePos[curNode]).normalized();
    hit = rayCircleListIntersect(circlePosArr, circleRadArr, numObstacles, nodePos[curNode], dir, segmentLength);
    if (hit.hit) numCollisions += 1;
  }
  
  int lastNode = curPath.get(curPath.size()-2);
  segmentLength = newNodePos[lastNode].distanceTo(goalPos);
  pathLength += segmentLength;
  dir = goalPos.minus(newNodePos[lastNode]).normalized();
  hit = rayCircleListIntersect(circlePosArr, circleRadArr, numObstacles, nodePos[lastNode], dir, segmentLength);
  if (hit.hit) numCollisions += 1;
}

 public Vec2 sampleFreePos(){
  Vec2 randPos = new Vec2(random(width),random(height));
  boolean insideAnyCircle = pointInCircleList(circlePosArr,circleRadArr,numObstacles,randPos,2);
  while (insideAnyCircle){
    randPos = new Vec2(random(width),random(height));
    insideAnyCircle = pointInCircleList(circlePosArr,circleRadArr,numObstacles,randPos,2);
  }
  return randPos;
}

 public void testPRM(){
    long startTime, endTime;
    curPath.clear();

    generateRandomNodes(numNodes, circlePosArr, circleRadArr);
    connectNeighbors(circlePosArr, circleRadArr, numObstacles, nodePos, numNodes);
  
//   startTime = System.nanoTime();
//   curPath = planPath(startPos, goalPos, circlePosArr, circleRadArr, numObstacles, nodePos, numNodes, 1);
//   endTime = System.nanoTime();
//   pathQuality();
  
//   println("BFS Path:");
//   println("Nodes:", numNodes," Obstacles:", numObstacles," Time (us):", int((endTime-startTime)/1000),
//           " Path Len:", pathLength, " Path Segment:", curPath.size()+1,  " Num Collisions:", numCollisions, '\n');

    // startTime = System.nanoTime();
    curPath = planPath(startPos, goalPos, circlePosArr, circleRadArr, numObstacles, nodePos, numNodes);
    // endTime = System.nanoTime();
    // pathQuality();

    // println("A* Path:");
    // println("Nodes:", numNodes," Obstacles:", numObstacles," Time (us):", int((endTime-startTime)/1000),
    //         " Path Len:", pathLength, " Path Segment:", curPath.size()+1,  " Num Collisions:", numCollisions, '\n');
}

//Returns true if the point is inside a circle
//You must consider a point as colliding if it's distance is <= eps
 public boolean pointInCircle(Vec2 center, float r, Vec2 pointPos, float eps){
    float dist = pointPos.distanceTo(center);
    if (dist < r+eps){ //small safety factor
        return true;
    }
    return false;
}

//Returns true if the point is inside a list of circle
//You must consider a point as colliding if it's distance is <= eps
 public boolean pointInCircleList(Vec2[] centers, float[] radii, int numObstacles, Vec2 pointPos, float eps){
    for (int i = 0; i < numObstacles; i++){
        if (validCircles[i]) {
            Vec2 center =  centers[i];
            float r = radii[i];
            if (pointInCircle(center,r,pointPos, eps)){
                return true;
            }
        } 
    }
    return false;
}

//Returns true if the point is inside a list of circle
//You must consider a point as colliding if it's distance is <= eps
 public boolean startOrGoalInCircleList(Vec2[] centers, float[] radii, int numObstacles, Vec2 pointPos, float eps){
    for (int i = 0; i < numObstacles; i++){
        Vec2 center =  centers[i];
        float r = radii[i];
        if (pointInCircle(center,r,pointPos, eps)){
            return true;
        }
    }
    return false;
}

//Returns true if the point is inside a list of circle
//You must consider a point as colliding if it's distance is <= eps
 public int getIndexPointInCircleList(Vec2[] centers, float[] radii, int numObstacles, Vec2 pointPos, float eps){
    for (int i = 0; i < numObstacles; i++){
        Vec2 center =  centers[i];
        float r = radii[i];
        if (pointInCircle(center,r,pointPos, eps)){
            return i;
        }
    }
    return -1;
}
// Project 1 Part 2 -- hend0800, cheon051
/////////////////////////////
// SOURCES
// Camera Code: Professor Guy -- Modified by hend0800
// Cylinder: https://vormplus.be/full-articles/drawing-a-cylinder-with-processing 
// Kiwi: Lauren Oliver
// Planet Textures: http://planetpixelemporium.com/planets.html
// Spaceship: https://www.cgtrader.com/free-3d-models/space/spaceship/free-flying-saucer

// scene dimensions
float sceneX = 3000;
float sceneY = 3000;
float sceneZ = 3000;

// model info
int kiwiFrames = 4;
PShape[] shapes = new PShape[kiwiFrames];
PImage[] textures = new PImage[10];
PShape[] planets = new PShape[10];
int[] times = new int[kiwiFrames];
PShape kiwi;
int kiwiScale = 10;
float kiwiWidth = 1*kiwiScale; // units // Scale(10) --> 10 units
float kiwiLength = 2.5f*kiwiScale; // units // Scale(10) --> 22.5 units
float kiwiHeight = 1.75f*kiwiScale; // units // Scale(10) --> 17.5 units
float kiwiTime = 0;
int kiwiSwitchFrame = 0;
int currFrame = 0;
float kiwi_framerate = 24;
// float kiwiYOffset = -0.71*kiwiScale; // model starts below floor, offset height a bit to have it normal
float kiwiYOffset = 0; // this one because no need for floor
PImage[] skybox = new PImage[6];
float kiwiInShipHeight = -305;

// agent info
Vec2 lastVel = new Vec2(0,0);
Vec3 lastPos = new Vec3(0,0,0);
Vec2 agentVel = new Vec2(1,1);
Vec2 agentFinalVel = agentVel;
Vec3 agentPos = new Vec3(-sceneX/2+25,kiwiInShipHeight,-sceneZ/2+25);
Vec2 agentPos2 = new Vec2(agentPos.x, agentPos.z);
Vec2 startPos = new Vec2(-sceneX/2+25,-sceneZ/2+25);
Vec2 absStartPos = startPos;
Vec2 goalPos = new Vec2(sceneX/2-25, sceneZ/2-25);
float agentColRad = 2.5f*0.5f*kiwiScale;
float agentDir = 0;

Vec2 backDir = agentVel.times(-1);
Vec2 forwardDir2 = agentVel;
Vec2 backVel = agentVel.times(-1);

float kiwiDir = 0;
float goalSpeed = 100;

// obstacles
ArrayList<Vec3> circleVel = new ArrayList<Vec3>();
ArrayList<Vec3> circlePos = new ArrayList<Vec3>();
ArrayList<Float> circleDrawRad = new ArrayList<Float>();
ArrayList<Float> circleColRad = new ArrayList<Float>();
ArrayList<Vec3> circleColor = new ArrayList<Vec3>();
ArrayList<PShape> circleShape = new ArrayList<PShape>();
ArrayList<Float> circleRot = new ArrayList<Float>();
ArrayList<Float> circleRotRate = new ArrayList<Float>();
ArrayList<Float[]> circleTilt = new ArrayList<Float[]>();
float obstacleWallPadding = 75;

// kiwi particles
ArrayList<Vec3> particlePos = new ArrayList<Vec3>();
ArrayList<Vec3> particleVel = new ArrayList<Vec3>();
ArrayList<Vec3> particleCol = new ArrayList<Vec3>();
Vec3 startColor = new Vec3(254, 240, 1);
Vec3 endColor = new Vec3(240, 5, 5);
Vec3 smoke = new Vec3(50, 50, 50);
FloatList particleLife = new FloatList();
int maxParticles = 200;
int numParticles = 0;
float genRate = 200;
float coneRad = radians(10);
float maxLife = 0.5f;

Camera camera;

// useful things
float ninety, oneeighty, twoseventy, threesixty;
float epsilon = 2;
float t = 0.91f;

// drawing info
int strokeWidth = 2;
PImage conkcrete;
PShape back;
PShape ship;

// key state variables
boolean moveObjects = false;
boolean mouseCast = false;
boolean paused = true;
boolean is3d = true;
boolean cameraFollowAgent = false;
boolean firstPerson = false;
float agentBackY = -75;
boolean agentBackYUp, agentBackYDown;
boolean atGoal = false;
boolean stopParticles = false;
boolean kiwiOnGround = false;
boolean noGoal = false;
Vec3 mouseRay, mouseOrig;
Vec2 shipMove = new Vec2(0,0);
Vec2 shipMoveNeg = new Vec2(0,0);
Vec2 shipMovePos = new Vec2(0,0);

Vec2 cameraForward = new Vec2(0,0);
Vec2 cameraBackward = new Vec2(0,0);
Vec2 cameraLeft = new Vec2(0,0);
Vec2 cameraRight = new Vec2(0,0);

float ship1Rot = 0;
float ship1RotRate = random(0.01f,0.1f);
float ship2Rot = 0;
float ship2RotRate = random(0.01f,0.1f);

// pathing
int indexCounter;
int startNode;
int currNode;
Vec2 currPos;
int nextNode;
Vec2 nextPos;
int goalNode;

 public void setup() {
    /* size commented out by preprocessor */;
    surface.setTitle("CSCI 5611 Project 1 Part 2");
    surface.setResizable(true);
    surface.setLocation(500,500);
    strokeWeight(2);

    camera = new Camera();

    // useful things
    oneeighty = radians(180);
    ninety = radians(90);
    twoseventy = radians(270);
    threesixty = radians(360);

    // image/model loading
    conkcrete = loadImage("data/conkcrete.jpg");

    ship = loadShape("data/Low_poly_UFO.obj");

    textures[0] = loadImage("data/sun.jpg");
    textures[1] = loadImage("data/mercury.jpg");
    textures[2] = loadImage("data/venus.jpg");
    textures[3] = loadImage("data/earth.jpg");
    textures[4] = loadImage("data/mars.jpg");
    textures[5] = loadImage("data/saturn.jpg");
    textures[6] = loadImage("data/neptune.jpg");
    textures[7] = loadImage("data/jupiter.jpg");
    textures[8] = loadImage("data/pluto.jpg");
    textures[9] = loadImage("data/uranus.jpg");

    // skybox[0] = loadImage("data/spacebox1.jpg");
    // skybox[1] = loadImage("data/spacebox2.jpg");
    // skybox[2] = loadImage("data/spacebox3.jpg");
    // skybox[3] = loadImage("data/spacebox4.jpg");
    // skybox[4] = loadImage("data/spacebox5.jpg");
    // skybox[5] = loadImage("data/spacebox6.jpg");

    // back = loadImage("data/back.jpg");
    
    noStroke();
    sphereDetail(200);
    back = createShape(SPHERE, 4000);
    PImage text = loadImage("data/blackhole.jpg");
    back.setTexture(text);

    placeRandomObstacles();

    String base = "data/kiwi";
    for (int i = 1; i <= kiwiFrames; i++) {
        String file = base + i + ".obj";
        shapes[i-1] = loadShape(file);
    }
    times[0] = 5; times[2] = 5;
    times[1] = 2; times[3] = 2;

    initiatePathfinding();
}

 public void randomizeStart() {
    startPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f), random(-sceneZ*0.5f, sceneZ*0.5f));
    while (startOrGoalInCircleList(circlePosArr, circleRadArr, numObstacles, startPos, epsilon)) {
        startPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f), random(-sceneZ*0.5f, sceneZ*0.5f));
    }
    agentPos.x = startPos.x; agentPos.z = startPos.y;
    agentPos2 = startPos;
}

 public void randomizeGoal() {
    goalPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f), random(-sceneZ*0.5f, sceneZ*0.5f));
    while (startOrGoalInCircleList(circlePosArr, circleRadArr, numObstacles, startPos, epsilon)) {
        goalPos = new Vec2(random(-sceneX*0.5f, sceneX*0.5f), random(-sceneZ*0.5f, sceneZ*0.5f));
    }
}

 public void placeRandomObstacles(){
    //Initial obstacle position
    sphereDetail(15);
    fill(255);
    noStroke();
    // clear things in case of reset
    circleDrawRad.clear();
    circlePos.clear();
    circleColor.clear();
    circleRot.clear();
    circleRotRate.clear();
    circleColRad.clear();
    circleShape.clear();
    circleTilt.clear();

    circleDrawRad.add(30.0f); //Make the first obstacle big
    circleColRad.add(30.0f+agentColRad);
    circlePos.add(new Vec3(
        random(-sceneX*0.5f+obstacleWallPadding,sceneX*0.5f-obstacleWallPadding),
        random(-100,100),
        random(-sceneZ*0.5f,sceneZ*0.5f)
    ));
    PShape globe = createShape(SPHERE, 30);
    globe.setTexture(textures[PApplet.parseInt(random(10))]);
    circleShape.add(globe);
    validCircles[0] = false;
    circleRot.add(random(0, radians(359)));
    circleRotRate.add(random(0.001f, 0.05f));
    circleTilt.add(new Float[]{random(-radians(45), radians(45)), random(-radians(45), radians(45))});

    for (int i = 1; i < numObstacles; i++){
        float rad = (10+40*pow(random(1),3));
        circleDrawRad.add(rad);
        circleColRad.add(rad+agentColRad);
        circlePos.add(new Vec3(
            random(-sceneX*0.5f+obstacleWallPadding,sceneX*0.5f-obstacleWallPadding),
            random(-100, 100),
            random(-sceneZ*0.5f+obstacleWallPadding,sceneZ*0.5f-obstacleWallPadding)
        ));
        globe = createShape(SPHERE, rad);
        globe.setTexture(textures[PApplet.parseInt(random(10))]);
        circleShape.add(globe);
        validCircles[i] = false;
        circleRot.add(random(0, radians(359)));
        circleRotRate.add(random(0.001f, 0.05f));
        circleTilt.add(new Float[]{random(-radians(45), radians(45)), random(-radians(45), radians(45))});
    }
    strokeWeight(strokeWidth);
}

 public void reset() {
    placeRandomObstacles();
    initiatePathfinding();
    kiwiTime = 0;
    kiwiSwitchFrame = 0;
    currFrame = 0;
    agentPos = new Vec3(startPos.x, kiwiInShipHeight, startPos.y);
    absStartPos.x = startPos.x; absStartPos.y = startPos.y;
    Vec2 agentFinalVel = agentVel;
    Vec2 backDir = agentVel.times(-1);
    Vec2 backVel = agentVel.times(-1);
    atGoal = false;
    stopParticles = false;
    kiwiOnGround = false;
    particlePos = new ArrayList<Vec3>();
    particleVel = new ArrayList<Vec3>();
    particleCol = new ArrayList<Vec3>();
    particleLife = new FloatList();
    numParticles = 0;
}

 public void initiatePathfinding() {
    for (int i = 0; i < circlePos.size(); i++) {
        Vec3 pos = circlePos.get(i);
        float rad = circleColRad.get(i);
        if ((abs(pos.y)-circleColRad.get(i)) < agentColRad) {
            validCircles[i] = true;
        } 
        circlePosArr[i] = new Vec2(pos.x, pos.z);
        circleRadArr[i] = rad;
    }

    // if random start and goal, uncomment this
    randomizeStart();
    randomizeGoal();

    absStartPos.x = startPos.x; absStartPos.y = startPos.y;

    testPRM();
    int iters = 0;
    while (curPath.size() == 1 && iters != 3) {
        testPRM();
        iters++;
    }
    if (iters == 3) {
        reset();
        return;
    }
    noGoal = false;
    indexCounter = 1;
    nextNode = curPath.get(1);
    goalNode = curPath.get(curPath.size()-1);
    nextPos = newNodePos[nextNode];
    agentVel = nextPos.minus(startPos).normalized().times(goalSpeed);
}
 public void update(float dt) {
    if (is3d) {
        if (!atGoal) {
            if (abs(agentPos.y-kiwiYOffset) > 1 && !kiwiOnGround) {
                agentPos.y = agentPos.y*0.99f + kiwiYOffset*(1-0.99f);
            } else {
                kiwiOnGround = true;
                agentPos.y = kiwiYOffset;
            }  
        }

        if (atGoal && !kiwiOnGround) {
            if (abs(agentPos.y-kiwiInShipHeight) > 1) {
                agentPos.y = agentPos.y*0.99f + kiwiInShipHeight*(1-0.99f);
            }
        } else if (atGoal && kiwiOnGround) {
            kiwiOnGround = false;
        }

        for (int i = 0; i < numObstacles; i++) {
            float rot = circleRot.get(i);
            float rotRate = circleRotRate.get(i);
            rot += rotRate;
            circleRot.set(i, rot);
        }
    } else {
        if (!atGoal) {
            kiwiOnGround = true;
            agentPos.y = kiwiYOffset;
        } else {
            kiwiOnGround = false;
            agentPos.y = kiwiInShipHeight;
        }
        
    }
    
    

    if (((is3d && kiwiOnGround) || !is3d) && !noGoal) {
        float dist = agentPos.distanceTo(nextPos);
        if (dist < goalSpeed*dt) {
            if (nextNode == goalNode) {
                agentPos.x = goalPos.x;
                agentPos.y = kiwiYOffset;
                agentPos.z = goalPos.y;
                // agentVel.x = 0; agentVel.y = 0;
                // agentFinalVel.x = 0; agentFinalVel.y = 0;
                atGoal = true;
                // cameraFollowAgent = false;
                // firstPerson = false;
                stopParticles = true;
            } else {
                agentPos = new Vec3(nextPos.x, agentPos.y, nextPos.y);
                indexCounter++;
                nextNode = curPath.get(indexCounter);
                nextPos = newNodePos[nextNode];
            }
        } else if (nextNode != goalNode) {
            Vec2 nextNextPos = newNodePos[curPath.get(indexCounter+1)];
            dist = agentPos.distanceTo(nextNextPos);
            Vec2 dir = nextNextPos.minus(new Vec2(agentPos.x, agentPos.z)).normalized();
            hitInfo hit = rayCircleListIntersect(circlePosArr, circleRadArr, numObstacles, new Vec2(agentPos.x, agentPos.z), dir, dist);
            if (!hit.hit) {
                indexCounter++;
                nextNode = curPath.get(indexCounter);
                nextPos = newNodePos[nextNode];
            }
        }   
        if (!atGoal) {
            agentFinalVel = nextPos.minus(new Vec2(agentPos.x, agentPos.z)).normalized().times(goalSpeed);
            agentVel = interpolate(agentVel, agentFinalVel, 0.05f*goalSpeed/100);
            backVel = agentVel.times(-1);
            backDir = interpolate(backDir, backVel, 0.01f*goalSpeed/100);
            forwardDir2 = interpolate(forwardDir2, agentVel.normalized(), 0.13f);

            if (agentVel.length() != goalSpeed) {
                agentVel = agentVel.normalized().times(goalSpeed);
            }
            agentPos.add(agentVel.times(dt));
        }
    }
}

 public void updateKiwiFrame() {
    if (noGoal) {
        agentDir += 0.05f;
    } else {
        agentDir = agentDir*t+(1-t)*atan2(agentVel.x, agentVel.y);
    }
    
    if (kiwiOnGround) {
        kiwiTime += agentVel.length()*0.005f;
        if (kiwiTime > 1/kiwi_framerate) {
            kiwiTime = 0;
            kiwiSwitchFrame++;
            if (kiwiSwitchFrame == times[currFrame]) {
                kiwiSwitchFrame = 0;
                currFrame = (currFrame+1)%kiwiFrames;
            }
        }
    }
}

 public void updateKiwiParticles(float dt) {
    if (!stopParticles && kiwiOnGround && !noGoal) {
        float toGen_float = genRate*dt;
        int toGen = PApplet.parseInt(toGen_float);
        float fractPart = toGen_float-toGen;
        if (random(1) < fractPart) toGen++;
        if (numParticles < maxParticles) {
            for (int p = 0; p < toGen; p++) {
                particlePos.add(
                    agentPos.plus(backDir.normalized().times(agentColRad-0.5f*kiwiScale))
                );
                particleVel.add(new Vec3(
                    backDir.x + random(-30, 30),
                    agentPos.y + random(-30, 30),
                    backDir.y + random(-30, 30)
                ).normalized().times(goalSpeed));
                particleCol.add(startColor);
                particleLife.append(0.0f);
                numParticles++;
            }
        }
    }
    

    for (int i = 0; i < numParticles; i++) {
        float life = particleLife.get(i);
        particleLife.set(i, life+dt);
        if (life < maxLife) {
            Vec3 col = particleCol.get(i);
            Vec3 currPos = particlePos.get(i);

            currPos.add(particleVel.get(i).times(dt));
            if (life < maxLife * 0.8f) {
                particleCol.set(i, interpolate(col, endColor, 0.3f));
            } else {
                particleCol.set(i, interpolate(col, smoke, 0.2f));
            }
            

            particlePos.set(i, currPos);
        } else {
            particlePos.remove(i);
            particleVel.remove(i);
            particleLife.remove(i);
            particleCol.remove(i);
            numParticles--;
        }
    }
}

//Vector Library
//CSCI 5611 Vector 2 Library [Example]
// Stephen J. Guy <sjguy@umn.edu>

public class Vec2 {
  public float x, y;
  
  public Vec2(float x, float y){
    this.x = x;
    this.y = y;
  }
  
  public String toString(){
    return "(" + x+ "," + y +")";
  }
  
  public float length(){
    return sqrt(x*x+y*y);
  }
  
  public float lengthSqr(){
    return x*x+y*y;
  }
  
  public Vec2 plus(Vec2 rhs){
    return new Vec2(x+rhs.x, y+rhs.y);
  }
  
  public void add(Vec2 rhs){
    x += rhs.x;
    y += rhs.y;
  }
  
  public Vec2 minus(Vec2 rhs){
    if (rhs == null) {
      return new Vec2(x, y);
    }
    return new Vec2(x-rhs.x, y-rhs.y);
  }

  public Vec2 minus(Vec3 rhs) {
    return new Vec2(x-rhs.x, y-rhs.z);
  }
  
  public void subtract(Vec2 rhs){
    x -= rhs.x;
    y -= rhs.y;
  }
  
  public Vec2 times(float rhs){
    return new Vec2(x*rhs, y*rhs);
  }
  
  public void mul(float rhs){
    x *= rhs;
    y *= rhs;
  }
  
  public void clampToLength(float maxL){
    float magnitude = sqrt(x*x + y*y);
    if (magnitude > maxL){
      x *= maxL/magnitude;
      y *= maxL/magnitude;
    }
  }
  
  public void setToLength(float newL){
    float magnitude = sqrt(x*x + y*y);
    x *= newL/magnitude;
    y *= newL/magnitude;
  }
  
  public void normalize(){
    float magnitude = sqrt(x*x + y*y);
    x /= magnitude;
    y /= magnitude;
  }
  
  public Vec2 normalized(){
    float magnitude = sqrt(x*x + y*y);
    return new Vec2(x/magnitude, y/magnitude);
  }
  
  public float distanceTo(Vec2 rhs){
    float dx = rhs.x - x;
    float dy = rhs.y - y;
    return sqrt(dx*dx + dy*dy);
  }
}

 public Vec2 interpolate(Vec2 a, Vec2 b, float t){
  return a.plus((b.minus(a)).times(t));
}

 public float dot(Vec2 a, Vec2 b){
  return a.x*b.x + a.y*b.y;
}

 public Vec2 projAB(Vec2 a, Vec2 b){
  return b.times(a.x*b.x + a.y*b.y);
}
////////////////////////////////////////////////////////////////////////////////

// CSCI 5611 Vector 3 Library
// Noah J Hendrickson <hend0800@umn.edu>

public class Vec3 {
    public float x, y, z;

    public Vec3(float x, float y, float z){
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public String toString(){
        return "(" + x + "," + y + "," + z + ")";
    }

    public float length(){
        return sqrt(x*x+y*y+z*z);
    }

    public float lengthSqr() {
        return x*x+y*y+z*z;
    }

    public Vec3 plus(Vec3 rhs){
        return new Vec3(x+rhs.x, y+rhs.y, z+rhs.z);
    }

    public Vec3 plus(Vec2 rhs) {
        return new Vec3(x+rhs.x, y, z+rhs.y);
    }

    public void add(Vec3 rhs){
        x += rhs.x;
        y += rhs.y;
        z += rhs.z;
    }

    public void add(Vec2 rhs) {
        x+=rhs.x;
        z+=rhs.y;
    }

    public Vec3 minus(Vec3 rhs){
        return new Vec3(x-rhs.x, y-rhs.y, z-rhs.z);
    }

    public void subtract(Vec3 rhs){
        x -= rhs.x;
        y -= rhs.y;
        z -= rhs.z;
    }

    public Vec3 times(float rhs){
        return new Vec3(x*rhs, y*rhs, z*rhs);
    }

    public void mul(float rhs){
        x *= rhs;
        y *= rhs;
        z *= rhs;
    }

    public void clampToLength(float maxL){
        float magnitude = sqrt(x*x + y*y + z*z);
        if (magnitude > maxL){
            x *= maxL/magnitude;
            y *= maxL/magnitude;
            z *= maxL/magnitude;
        }
    }

    public void setToLength(float newL){
        float magnitude = sqrt(x*x + y*y);
        if (magnitude <= epsilon) return;
        x *= newL/magnitude;
        y *= newL/magnitude;
        z *= newL/magnitude;
    }

    public void normalize(){
        float magnitude = sqrt(x*x + y*y + z*z);
        if (magnitude > epsilon) {
            x /= magnitude;
            y /= magnitude;
            z /= magnitude;
        }
    }

    public Vec3 normalized(){
        float magnitude = sqrt(x*x + y*y + z*z);
        if (magnitude > epsilon) return new Vec3(x/magnitude, y/magnitude, z/magnitude);
        return new Vec3(x,y,z);
    }

    public float distanceTo(Vec3 rhs){
        float dx = rhs.x - x;
        float dy = rhs.y - y;
        float dz = rhs.z - z;
        return sqrt(dx*dx + dy*dy + dz*dz);
    }

    public float distanceTo(Vec2 rhs) {
        float dx = rhs.x - x;
        float dz = rhs.y - z;
        return (sqrt(dx*dx+dz*dz));
    }

    public void rotateAroundZ(float rad) {
        x = cos(rad)*x-sin(rad)*y;
        y = sin(rad)*x+cos(rad)*y;
        z = z;
    }

    public void rotateAroundY(float rad) {
        x = cos(rad)*x+sin(rad)*z;
        y = y;
        z = -sin(rad)*x+cos(rad)*z;
    }

    public void rotateAroundX(float rad) {
        x = x;
        y = cos(rad)*y-sin(rad)*z;
        z = sin(rad)*y+cos(rad)*z;
    }

    public Vec3 rotatedAroundZ(float rad) {
        float newx = cos(rad)*x-sin(rad)*y;
        float newy = sin(rad)*x+cos(rad)*y;
        float newz = z;
        return new Vec3(newx, newy, newz);
    }

    public Vec3 rotatedAroundY(float rad) {
        float newx = cos(rad)*x+sin(rad)*z;
        float newy = y;
        float newz = -sin(rad)*x+cos(rad)*z;
        return new Vec3(newx, newy, newz);
    }

    public Vec3 rotatedAroundX(float rad) {
        float newx = x;
        float newy = cos(rad)*y-sin(rad)*z;
        float newz = sin(rad)*y+cos(rad)*z;
        return new Vec3(newx, newy, newz);
    }
}

 public Vec3 interpolate(Vec3 a, Vec3 b, float t){
  return a.plus((b.minus(a)).times(t));
  // a + ((b-a)*t)
}

 public float interpolate(float a, float b, float t){
  return a + ((b-a)*t);
}

 public float dot(Vec3 a, Vec3 b){
  return a.x*b.x + a.y*b.y + a.z*b.z;
}

 public Vec3 cross(Vec3 a, Vec3 b) {
    float newx = a.y*b.z - a.z*b.y;
    float newy = a.z*b.x - a.x*b.z;
    float newz = a.x*b.y - a.y*b.x;

    return new Vec3(newx, newy, newz);
}

 public Vec3 projAB(Vec3 a, Vec3 b){
  return b.times(a.x*b.x + a.y*b.y + a.z*b.z);
}

 public float rotateTo(Vec3 a, Vec3 b) {
    Vec3 cross = cross(a, b);
    float first = cross.x+cross.y+cross.z;
    return atan2(first, dot(a,b));
}

// for detecting the edges of the area
 public float rayIntersectPlaneTime(Vec3 normal, Vec3 normPoint, Vec3 origin, Vec3 ray) {
    float denom = dot(normal, ray);
    if (denom > epsilon) {
        Vec3 pl = normPoint.minus(origin);
        float t = dot(pl, normal) / denom;
        if (t >= 0) return t;
        return Float.NaN;
    }
    return Float.NaN;
}

// for detecting collisions between other keewers
 public float rayIntersectSphereTime(Vec3 center, float radius, Vec3 origin, Vec3 ray) {
    Vec3 toCircle = center.minus(origin);

    float a = ray.length()*ray.length(); // square the length of the ray
    float b = -2*dot(ray, toCircle); // 2*dot between ray and dir from pos to center of circle
    float c = toCircle.lengthSqr() - (radius*radius); // difference of squares

    float d = b*b - 4*a*c; // discriminant

    if (d >= 0) {
        float t = (-b-sqrt(d))/(2*a); // only need first intersection
        if (t >= 0) return t; // only return if going to collide
        return Float.NaN; 
    }
    return Float.NaN; // no colliding
}


  public void settings() { size(1300, 1300, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "camera" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
